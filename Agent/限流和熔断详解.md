# 限流和熔断详解

## 📚 目录

1. [限流（Rate Limiting）详解](#限流rate-limiting详解)
2. [熔断（Circuit Breaker）详解](#熔断circuit-breaker详解)
3. [两者的关系和区别](#两者的关系和区别)
4. [项目中的实现](#项目中的实现)
5. [实际应用场景](#实际应用场景)
6. [常见问题解答](#常见问题解答)

---

## 🚦 限流（Rate Limiting）详解

### 什么是限流？

**限流（Rate Limiting）** 是一种控制请求数量的机制，用来限制在特定时间窗口内可以处理多少请求。

**简单比喻**：
想象一家餐厅，即使有100个座位，如果同时涌入1000个客人，厨房会忙不过来，服务质量会下降。限流就像是"预约系统"，告诉客人："我们每小时只能接待50桌客人，请排队等待。"

### 限流的三个层次

#### 1. **API限流**（项目中的实现）

**作用**：限制每个客户端在特定时间内的请求次数

**我们项目中的实现**：`utils/security.py` - `RateLimiter`

```python
class RateLimiter:
    """每分钟限流器"""
    
    def __init__(self, rate_limit_per_minute: int):
        self.rate_limit = rate_limit_per_minute  # 比如60次/分钟
        self._requests = defaultdict(deque)  # 记录每个客户端的请求时间
    
    async def check(self, identifier: str):
        # 检查过去60秒内的请求数
        # 如果超过限制，抛出异常
```

**实际例子**：
```python
# 配置：每分钟最多60个请求
rate_limiter = RateLimiter(rate_limit_per_minute=60)

# 客户端A在1分钟内发送了61个请求
# 第61个请求会被拒绝，返回429错误："Too many requests"
```

**应用场景**：
- 防止恶意攻击（DDoS攻击）
- 保护系统资源不被耗尽
- 公平分配系统资源
- 防止单个用户占用过多资源

#### 2. **并发限流**（项目中的实现）

**作用**：限制同时处理的请求数量

**我们项目中的实现**：`utils/concurrency_limiter.py` - `ConcurrencyLimiter`

```python
class ConcurrencyLimiter:
    """并发限制器 - 使用信号量控制"""
    
    def __init__(self, max_concurrent: int = 10):
        self.max_concurrent = max_concurrent  # 最多同时处理10个请求
        self.semaphore = asyncio.Semaphore(max_concurrent)
```

**工作原理**：
```
想象有10个工位的餐厅：
- 当10个工位都有人时，新来的客人需要等待
- 有人离开后，等待的客人可以进入

并发限流就是这样：
- 最多10个请求同时处理
- 第11个请求必须等待前面的请求完成
```

**实际例子**：
```python
limiter = ConcurrencyLimiter(max_concurrent=10)

# 场景：有15个请求同时到达
# - 前10个请求：立即开始处理
# - 后5个请求：等待（阻塞），直到前面有请求完成
```

**应用场景**：
- 防止系统过载
- 保护数据库连接池
- 控制资源使用
- 保证系统稳定性

#### 3. **全局限流**

**作用**：限制整个系统的总请求量

**例子**：
```python
# 整个系统每分钟最多处理1000个请求
# 不管有多少客户端，总共不超过1000次/分钟
```

### 限流的算法

#### 1. **固定窗口限流**（我们使用的）

```
时间轴：0秒 -------- 60秒 -------- 120秒
窗口1：  [60个请求] 
窗口2：                [60个请求]

优点：简单、高效
缺点：可能在窗口边界出现突发流量
```

#### 2. **滑动窗口限流**（更精确）

```
时间轴：0秒 -------- 60秒 -------- 120秒
         [    滑动窗口    ]
                    [    滑动窗口    ]

优点：更平滑，不会出现边界突发
缺点：需要更多内存存储
```

#### 3. **令牌桶算法**

```
想象一个水桶：
- 水桶容量：100个令牌
- 每秒自动添加10个令牌
- 请求需要消耗1个令牌
- 如果桶空了，请求被拒绝

优点：允许突发流量
缺点：实现较复杂
```

### 限流的副作用

**优点**：
- ✅ 保护系统不被过载
- ✅ 防止资源耗尽
- ✅ 提高系统稳定性
- ✅ 公平分配资源

**缺点**：
- ⚠️ 可能会拒绝合法的请求
- ⚠️ 可能影响用户体验
- ⚠️ 需要合理设置阈值

---

## ⚡ 熔断（Circuit Breaker）详解

### 什么是熔断？

**熔断（Circuit Breaker）** 是一种防止级联失败的机制，当服务出现问题时，快速失败并暂时停止调用，给服务恢复的时间。

**简单比喻**：
就像家里的电路保险丝：
- 当电流过大时，保险丝**熔断**（断开）
- 保护电器不被烧坏
- 等一段时间后，检查问题是否解决
- 如果解决了，重新连接电路

### 熔断器的三种状态

#### 1. **关闭状态（CLOSED）** - 正常状态

```
[服务正常]
  ↓ 请求
[调用服务]
  ↓ 成功/失败
[记录结果]

- 正常情况下，所有请求都通过
- 记录成功和失败次数
```

#### 2. **打开状态（OPEN）** - 熔断状态

```
[服务异常]
  ↓ 失败次数达到阈值
[熔断器打开] ❌
  ↓ 请求
[直接拒绝] ⚡ 不调用服务

- 失败次数达到阈值（如5次）
- 所有新请求立即被拒绝
- 不调用实际服务，节省资源
```

#### 3. **半开状态（HALF_OPEN）** - 试探状态

```
[熔断器打开]
  ↓ 等待一段时间（如30秒）
[进入半开状态] 🔄
  ↓ 允许少量请求通过
[测试服务是否恢复]
  ↓ 
[成功 → 关闭] / [失败 → 重新打开]

- 给服务恢复的时间
- 尝试少量请求
- 根据结果决定是关闭还是重新打开
```

### 熔断器的工作流程

```
正常状态 (CLOSED)
    ↓
服务开始失败
    ↓
失败次数 < 阈值 → 继续尝试
    ↓
失败次数 ≥ 阈值 → 打开熔断 (OPEN)
    ↓
等待30秒（恢复超时）
    ↓
进入半开状态 (HALF_OPEN)
    ↓
尝试几个请求
    ↓
    ├─→ 成功2次 → 关闭熔断 (CLOSED) ✅
    └─→ 失败 → 重新打开 (OPEN) ❌
```

### 我们项目中的实现

**实现文件**：`utils/circuit_breaker.py`

```python
class CircuitBreaker:
    def __init__(
        self,
        failure_threshold: int = 5,      # 失败5次后打开
        recovery_timeout: float = 30.0,  # 30秒后进入半开
        name: str = "circuit_breaker"
    ):
        self.state = CircuitState.CLOSED
        self.failure_count = 0
        self.last_failure_time = None
```

**实际应用**：LLM调用熔断保护

```python
# 在 services/llm_client.py 中
self._circuit_breaker = CircuitBreaker(
    failure_threshold=5,      # 5次失败后熔断
    recovery_timeout=30.0,    # 30秒后尝试恢复
    name="llm_client"
)

async def _call_openai_compatible(...):
    async def _make_request():
        # 实际的LLM调用
        ...
    
    # 通过熔断器调用
    return await self._circuit_breaker.call(_make_request)
```

### 熔断器的好处

**防止级联失败**：
```
没有熔断器的情况：
请求1 → 服务A（慢） → 等待 → 超时
请求2 → 服务A（慢） → 等待 → 超时
请求3 → 服务A（慢） → 等待 → 超时
...
所有请求都被阻塞，系统完全不可用 ❌

有熔断器的情况：
请求1-5 → 服务A（失败） → 记录失败
熔断器打开 → 拒绝后续请求 ⚡
请求6-10 → 立即返回错误（快速失败）
系统其他部分仍然可用 ✅
```

**节省资源**：
```
没有熔断器：
- 即使服务已经崩溃，仍然不断尝试调用
- 消耗CPU、内存、网络资源
- 可能导致系统完全卡死

有熔断器：
- 熔断后不再调用失败的服务
- 节省资源
- 系统保持响应
```

---

## 🔄 两者的关系和区别

### 相同点

1. **都是保护机制**：保护系统不被过载
2. **都有阈值**：达到阈值后触发动作
3. **都能自动恢复**：问题解决后自动恢复正常

### 不同点

| 特性 | 限流（Rate Limiting） | 熔断（Circuit Breaker） |
|------|---------------------|----------------------|
| **目的** | 控制请求数量 | 防止级联失败 |
| **触发条件** | 请求数超过限制 | 失败次数达到阈值 |
| **动作** | 拒绝多余的请求 | 暂时停止所有请求 |
| **关注点** | **数量**（多少请求） | **质量**（服务是否正常） |
| **恢复方式** | 时间窗口过去 | 服务恢复正常 |
| **适用场景** | 正常流量控制 | 异常情况处理 |

### 实际配合使用

```
请求进来
    ↓
[限流检查] → 是否超过每分钟限制？
    ├─ 是 → 拒绝请求 ❌
    └─ 否 → 继续
        ↓
[并发限制] → 是否超过并发数？
    ├─ 是 → 等待 ⏳
    └─ 否 → 继续
        ↓
[熔断器检查] → 服务是否熔断？
    ├─ 是 → 快速失败 ❌
    └─ 否 → 调用服务
        ↓
服务调用
    ├─ 成功 → 记录成功 ✅
    └─ 失败 → 记录失败 → 检查是否达到熔断阈值
```

---

## 💻 项目中的实现

### 1. API限流（Rate Limiter）

**位置**：`utils/security.py`

```python
class RateLimiter:
    """每分钟限流器"""
    
    # 配置：每分钟最多60个请求
    rate_limiter = RateLimiter(rate_limit_per_minute=60)

    # 使用：在每个API端点
    @router.post("/supportchat", dependencies=[Depends(enforce_rate_limit)])
    async def support_chat_endpoint(...):
        # 如果超过60次/分钟，自动拒绝
        ...
```

**实际效果**：
```
客户端A的请求时间线：
00:00 - 发送10个请求 ✅
00:30 - 发送50个请求 ✅（总共60个）
01:00 - 发送1个请求 ✅（新的一分钟开始）
00:30 - 再发送1个请求 ❌ 429错误（第61个）
```

### 2. 并发限流（Concurrency Limiter）

**位置**：`utils/concurrency_limiter.py`

```python
class ConcurrencyLimiter:
    """并发限制器"""
    
    # 配置：最多同时处理10个请求
    limiter = ConcurrencyLimiter(max_concurrent=10)

    # 使用：在Supervisor中
    async def handle_chat(...):
        async with self.concurrency_limiter:
            # 如果已经有10个请求在处理，这里会等待
            # 处理请求
            ...
```

**实际效果**：
```
时间点T0：
- 请求1-10：立即开始处理 ✅
- 请求11-15：等待 ⏳

时间点T1（请求1完成）：
- 请求11：开始处理 ✅
- 请求12-15：继续等待 ⏳
```

### 3. 熔断器（Circuit Breaker）

**位置**：`utils/circuit_breaker.py`，集成在 `services/llm_client.py`

```python
class CircuitBreaker:
    """熔断器"""
    
    # 配置：5次失败后熔断，30秒后恢复
    breaker = CircuitBreaker(
        failure_threshold=5,
        recovery_timeout=30.0
    )

    # 使用：在LLM调用中
    async def _call_openai_compatible(...):
        return await self._circuit_breaker.call(_make_request)
```

**实际效果**：
```
场景：LLM服务暂时不可用

请求1-5：调用LLM → 失败 → 记录失败
请求6：调用LLM → 失败 → 达到阈值 → 打开熔断 ⚡
请求7-20：立即返回错误（不调用LLM）→ 快速失败
等待30秒...
请求21：尝试调用 → 成功 → 关闭熔断 ✅
请求22+：正常调用
```

---

## 🎯 实际应用场景

### 场景1：防止恶意攻击

**问题**：恶意用户不断发送请求，试图让系统崩溃

**解决方案**：
```
[限流] 限制每分钟请求数
- 正常用户：每分钟10个请求 ✅
- 攻击者：每分钟1000个请求 ❌ 被限制

效果：系统稳定运行
```

### 场景2：外部服务故障

**问题**：LLM服务暂时不可用，但我们还在不断调用

**解决方案**：
```
[熔断器] 检测到5次失败后停止调用
- 请求1-5：调用 → 失败 → 记录
- 请求6+：快速返回错误（不调用）✅

效果：节省资源，系统其他功能正常
```

### 场景3：系统过载

**问题**：同时有100个请求，但系统只能处理10个

**解决方案**：
```
[并发限制] 限制同时处理的请求数
- 前10个：立即处理 ✅
- 后90个：等待，依次处理 ✅

效果：系统稳定，不会崩溃
```

### 场景4：第三方API限制

**问题**：第三方API限制每分钟100次调用，但我们有200个请求

**解决方案**：
```
[限流] 限制到每分钟100次
- 前100个：立即调用 ✅
- 后100个：等待下一分钟 ✅

效果：遵守API限制，避免被封禁
```

---

## ❓ 常见问题解答

### Q1: 限流会不会影响正常用户？

**A**: 合理配置的限流不会影响正常用户。

**例子**：
```python
# 配置：每分钟60次（平均每秒1次）
# 正常用户：每分钟5-10次请求 ✅ 完全够用
# 异常用户：每分钟100次请求 ❌ 被限制

# 如果正常用户也觉得不够，可以提高限制
rate_limit_per_minute=300  # 每分钟300次
```

### Q2: 熔断器会不会误判？

**A**: 可以配置参数来减少误判。

```python
# 配置更严格的阈值
breaker = CircuitBreaker(
    failure_threshold=10,      # 提高到10次才熔断
    recovery_timeout=60.0,     # 等待更长时间
)

# 这样只有真正出问题才会熔断
```

### Q3: 并发限制和限流有什么区别？

**A**: 关注点不同：

- **限流**：关注**时间窗口内的请求总数**
  - "1分钟内最多60个请求"
  
- **并发限制**：关注**同时处理的请求数**
  - "最多同时处理10个请求"

**例子**：
```
限流（每分钟60次）：
- 00:00-00:59：处理60个请求 ✅
- 01:00-01:59：再处理60个请求 ✅

并发限制（最多10个）：
- 时刻T：同时处理10个请求 ✅
- 不管1分钟处理了多少个，同时不超过10个
```

### Q4: 什么时候需要限流？什么时候需要熔断？

**A**: 

**需要限流**：
- ✅ 正常情况下的流量控制
- ✅ 防止单个用户占用过多资源
- ✅ 遵守第三方API限制
- ✅ 公平分配资源

**需要熔断**：
- ✅ 外部服务不稳定
- ✅ 需要快速失败，避免等待
- ✅ 防止级联失败
- ✅ 保护系统不被拖垮

### Q5: 如何配置合理的阈值？

**A**: 根据实际情况调整：

```python
# 限流阈值
rate_limit_per_minute = 估算的峰值流量 × 1.5
# 例如：峰值50次/分钟 → 设置75次/分钟

# 并发限制
max_concurrent = 系统CPU核心数 × 2-4
# 例如：4核CPU → 设置8-16

# 熔断阈值
failure_threshold = 根据服务稳定性设置
# 例如：稳定服务 → 5-10次
#      不稳定服务 → 3-5次
```

---

## 📊 可视化理解

### 限流的效果

```
没有限流：
请求数
  ↑
100│     ╱╲    ╱╲    ╱╲     ← 系统可能崩溃
 50│   ╱  ╲  ╱  ╲  ╱  ╲
  0│──┴────┴────┴────┴──→ 时间
         系统不稳定 ❌

有限流：
请求数
  ↑
100│
 50│ ──────────── ← 限制在50
  0│──┴────┴────┴────┴──→ 时间
         系统稳定 ✅
```

### 熔断器的状态转换

```
请求成功率
  ↑
100%│ ╱╲     ╱╲
    │╱  ╲   ╱  ╲
 50%│     ╲╱    ╲  ╱
    │      ❌熔断  ╲╱
  0%│────────────────────→ 时间
     正常   故障  恢复

状态: CLOSED → OPEN → HALF_OPEN → CLOSED
```

---

## 🔧 调试和监控

### 查看限流状态

```python
# 查看限流统计
limiter.get_stats()
# {
#   "current_count": 3,
#   "max_concurrent": 10,
#   "available": 7,
#   "waiting": 2
# }
```

### 查看熔断器状态

```python
# 查看熔断器状态
breaker.get_state()
# {
#   "name": "llm_client",
#   "state": "closed",  # 或 "open", "half_open"
#   "failure_count": 2,
#   "last_failure_time": None
# }
```

### 监控指标

访问 `/metrics` 端点可以查看：
- 请求总数
- 被限流的请求数
- 熔断器状态
- 并发请求数

---

## 📝 总结

### 限流（Rate Limiting）

**核心思想**：**控制数量**
- 限制请求的频率
- 防止系统被请求淹没
- 保证服务质量

**适用于**：
- 正常流量控制
- 资源分配
- API保护

### 熔断（Circuit Breaker）

**核心思想**：**快速失败**
- 检测服务健康状态
- 失败时快速拒绝，不等待
- 给服务恢复时间

**适用于**：
- 外部服务调用
- 故障隔离
- 防止级联失败

### 两者配合

```
限流（控制流量） + 熔断（快速失败） = 高可用的系统 ✅
```

**实际效果**：
- 正常情况：限流确保合理的流量
- 异常情况：熔断快速失败，不影响其他功能
- 系统稳定：不会因为一个问题导致整个系统崩溃

---

**希望这个解释帮助你理解限流和熔断的作用！** 🎉

如果有任何疑问，可以查看：
- 代码实现：`utils/circuit_breaker.py`, `utils/concurrency_limiter.py`, `utils/security.py`
- 使用示例：`services/llm_client.py`, `agents/support/supervisor.py`
"""
限流和熔断实战示例
通过代码演示限流和熔断的工作原理
"""

import asyncio
import time
from utils.circuit_breaker import CircuitBreaker, CircuitBreakerOpenError
from utils.concurrency_limiter import ConcurrencyLimiter
from utils.security import RateLimiter


# ============ 示例1: 限流（Rate Limiting） ============

async def example_rate_limiting():
    """示例：API限流的效果"""
    print("=" * 60)
    print("示例1: API限流（Rate Limiting）")
    print("=" * 60)
    
    # 创建一个每分钟只允许3个请求的限流器
    limiter = RateLimiter(rate_limit_per_minute=3)
    
    print("\n尝试发送5个请求（限制：3个/分钟）\n")
    
    for i in range(5):
        try:
            await limiter.check(f"client_A")
            print(f"  请求 {i+1}: ✅ 通过")
        except Exception as e:
            print(f"  请求 {i+1}: ❌ 被限流 - {e}")
        
        await asyncio.sleep(0.1)  # 快速发送请求
    
    print("\n等待61秒后...")
    await asyncio.sleep(2)  # 实际演示时等待61秒
    
    try:
        await limiter.check("client_A")
        print("  新请求: ✅ 通过（新的一分钟开始）")
    except Exception as e:
        print(f"  新请求: ❌ {e}")


# ============ 示例2: 并发限流（Concurrency Limiting） ============

async def simulate_processing_request(request_id: int, duration: float):
    """模拟处理一个请求（需要一些时间）"""
    print(f"  请求 {request_id}: 开始处理...")
    await asyncio.sleep(duration)
    print(f"  请求 {request_id}: ✅ 处理完成")


async def example_concurrency_limiting():
    """示例：并发限流的效果"""
    print("\n" + "=" * 60)
    print("示例2: 并发限流（Concurrency Limiting）")
    print("=" * 60)
    
    # 创建一个最多同时处理3个请求的限流器
    limiter = ConcurrencyLimiter(max_concurrent=3, name="example")
    
    print("\n同时发送8个请求（限制：最多同时处理3个）\n")
    
    async def process_with_limit(request_id: int):
        async with limiter:
            await simulate_processing_request(request_id, 1.0)
    
    # 同时启动8个请求
    tasks = [process_with_limit(i+1) for i in range(8)]
    start_time = time.time()
    
    await asyncio.gather(*tasks)
    
    elapsed = time.time() - start_time
    print(f"\n所有请求完成，耗时: {elapsed:.1f}秒")
    print("（如果没有并发限制，需要8秒；有限制需要约3秒）")


# ============ 示例3: 熔断器（Circuit Breaker） ============

async def simulate_unreliable_service(request_id: int) -> str:
    """模拟一个不稳定的服务（前5次失败，之后成功）"""
    if request_id <= 5:
        await asyncio.sleep(0.1)
        raise Exception(f"服务暂时不可用（模拟失败）")
    else:
        await asyncio.sleep(0.5)
        return f"服务响应 {request_id}"


async def example_circuit_breaker():
    """示例：熔断器如何工作"""
    print("\n" + "=" * 60)
    print("示例3: 熔断器（Circuit Breaker）")
    print("=" * 60)
    
    # 创建熔断器：5次失败后打开，30秒后恢复
    breaker = CircuitBreaker(
        failure_threshold=5,
        recovery_timeout=5.0,  # 演示用5秒（实际30秒）
        name="unreliable_service"
    )
    
    print("\n场景：服务前5次调用失败，之后恢复\n")
    
    for i in range(10):
        try:
            result = await breaker.call(simulate_unreliable_service, i+1)
            print(f"  请求 {i+1}: ✅ {result}")
            print(f"    熔断器状态: {breaker.state.value}")
        except CircuitBreakerOpenError as e:
            print(f"  请求 {i+1}: ⚡ 熔断器打开 - 快速失败（不调用服务）")
            print(f"    熔断器状态: {breaker.state.value}")
        except Exception as e:
            print(f"  请求 {i+1}: ❌ 服务失败 - {str(e)[:30]}")
            print(f"    熔断器状态: {breaker.state.value}")
            print(f"    失败计数: {breaker.failure_count}")
        
        # 在第6次失败后，等待一下让熔断器进入半开状态
        if i == 5:
            print(f"\n  等待5秒让熔断器进入半开状态...")
            await asyncio.sleep(5.5)
    
    print(f"\n最终状态: {breaker.get_state()}")


# ============ 示例4: 实际应用场景 ============

async def example_real_world_scenario():
    """示例：真实世界的应用场景"""
    print("\n" + "=" * 60)
    print("示例4: 真实应用场景")
    print("=" * 60)
    
    print("""
场景：LLM API调用

1. 限流保护：
   - 限制每分钟60次调用（避免超出API限制）
   - 如果超过，返回429错误

2. 并发限制：
   - 限制同时处理10个请求
   - 防止系统过载

3. 熔断保护：
   - 如果LLM服务连续失败5次
   - 打开熔断，快速失败
   - 30秒后尝试恢复

组合效果：
- 正常情况：流量平稳，系统稳定 ✅
- 异常情况：快速失败，不影响其他功能 ✅
- 恢复后：自动恢复正常工作 ✅
    """)


# ============ 主函数 ============

async def main():
    """运行所有示例"""
    print("\n" + "=" * 60)
    print("🚀 限流和熔断实战示例")
    print("=" * 60)
    
    # 示例1: API限流
    await example_rate_limiting()
    
    # 示例2: 并发限流
    await example_concurrency_limiting()
    
    # 示例3: 熔断器
    await example_circuit_breaker()
    
    # 示例4: 实际场景
    await example_real_world_scenario()
    
    print("\n" + "=" * 60)
    print("✅ 示例演示完成！")
    print("=" * 60)


if __name__ == "__main__":
    asyncio.run(main())

