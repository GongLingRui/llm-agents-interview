### 一、上下文隔离：多Agent协作的两种架构模式
- **问题的提出：多Agent系统的“噩梦”**
  多Agent系统虽强大，但让它们之间高效、无误地同步信息，是一场噩梦。这本质上是经典的**多线程通信问题**。
- **核心类比：借鉴Go语言并发哲学**
  *“不要通过共享上下文(Context)来通信；而要通过通信来共享上下文(Context)。”*
  （注：原文指出此比喻不完全适用，但它清晰地引出了两种不同的协作模式。）


### 二、两种协作模式的深度解析
| 维度          | 模式一：“通过通信”| 模式二：“通过共享上下文” |
|---------------|------------------------------------------|--------------------------------------------------|
| 核心思想      | 上下文不共享。子Agent就像一个一次性的“黑盒工具人” | 上下文只读共享。子Agent拥有完整的历史视野，但以一个全新的“身份”和“技能包”来行动 |
| 工作流程      | 1. 主Agent生成工具调用，如`code_searcher(query="...")`。<br>2. 框架创建全新的、干净的子Agent，其上下文只包含该指令。<br>3. 子Agent的最终产出，作为Observation返回给主Agent | 1. 主Agent发出“分叉(Fork)”动作。<br>2. 框架为一次全新的LLM调用构建Prompt：子Agent的新System Prompt + 主Agent的完整历史。<br>3. 子Agent独立完成任务，结果返回主Agent |
| 优点          | 轻量、高效、隔离性好、成本低               | 能处理高度依赖历史的复杂任务                     |
| 缺点          | 缺乏历史视野                             | 昂贵！<br>- 输入Token花费更多：因为需要预填充完整的历史记录。<br>- KV缓存完全失效：因为更换了System Prompt，无法重用缓存 |


### 三、总结与启示
- **架构选择的权衡（忠于原文）**
  - “通信模式”适用场景：任务有一个**简短、清晰的指令**，并且只关心**最终输出**。例如：在代码库中搜索特定代码片段。
  - “共享上下文模式”适用场景：更复杂的场景，最终报告**依赖于大量中间过程和历史笔记**。例如：进行一次深度研究并撰写报告。
- **给产品和开发的启示**
  在设计多Agent系统时，必须清醒地认识到两种模式的成本与收益。
  默认应优先考虑更轻量的**“通信模式”**。只有在任务确实需要完整历史背景时，才**谨慎地**使用“共享上下文模式”，并为其带来的更高延迟和成本做好准备。
