### 上下文工程终极指南

#### 问题的根源
- **Agent的本质**：在一个循环中调用工具的 LLM。
- **挑战 (上下文爆炸)**：长任务（如Manus的50次工具调用）会产生巨量上下文，导致成本和延迟急剧膨胀。
- **核心矛盾 (上下文腐烂)**：上下文越长，模型性能（如长距离推理、精确回忆）就越差。


#### 破局之道：三大核心支柱
**理念**：用恰到好处的、下一步所需的正确信息来填充上下文窗口。
- **卸载 (Offload)**：将上下文移到外部存储（如文件系统），以便后续选择性检索。
- **缩减 (Reduce)**：减小每一轮传递给模型的上下文大小（如压缩、总结）。
- **隔离 (Isolate)**：为不同的独立任务，使用单独的上下文窗口（即子Agent）。


### 支柱一：卸载 (Offload)

#### 1. 卸载“数据”（文件系统即上下文）
赋予Agent一个文件系统来保存和回忆信息。
- **对抗遗忘**：将计划写入 `todo.md`，执行后再读回计划，确保不偏离目标。
- **跨会话记忆**：使用 `claude.md` 等文件持久化存储用户偏好。


#### 2. 卸载“工具”（分层行动空间）
- **问题**：上百个工具会导致“模型混淆”和“Prompt臃肿”。
- **业界共识**：保持函数调用层（第一层）的极简，将“动作”卸载为外部脚本。
  - Claude Code: ~12个工具
  - Manus: < 20个工具
  - Deep Agents: 11个工具


#### 3. 演进：“渐进式披露”
连“脚本”也不必一开始就告知模型，让模型在需要时才去“发现”。
- **Anthropic Skills**：启动时只加载`skill.md`的“标题”，Agent决定使用时，才用`bash`工具完整读取。
- **Manus 实现**：Agent通过`bash`工具（如`ls`和`--help`），在脚本目录中自主“寻宝”。

### 支柱二：缩减 (Reduce) - “可逆”与“不可逆”

#### 压缩 (Compaction) - 可逆的
- **定义**：将陈旧的工具结果（Observation）完整卸载到文件，只在上下文中保留一个“指针”来替换它。
- **核心价值**：确保信息100%可恢复。


#### 摘要 (Summarization) - 不可逆的
- **时机**：当“压缩”收益变小或上下文接近极限（如95%）时才启用。
- **技巧**：应使用结构化Schema（填表）而非自由格式，以保证关键信息不丢失。

### 支柱三：隔离 (Isolate) - 多Agent协作模式

#### 模式一：“通过通信”
- **定义**：主Agent传递简短指令，子Agent在**隔离的、干净的上下文**中完成任务，只返回最终结果。
- **适用**：适合简单、可切分的任务（如代码搜索）。


#### 模式二：“通过共享上下文”
- **定义**：子Agent被允许访问父Agent的**完整历史**，但加载一套**新的System Prompt**。
- **适用**：适合复杂、依赖历史的任务（如研报撰写）。
- **核心权衡**：模式二非常昂贵。因为更换了System Prompt，导致KV缓存完全失效，必须支付“全价”。


  ### 结论 - 见证行业共识的形成
- **一个“大一统”的架构正在趋同**
  所有顶级的生产级Agent（Manus, Claude Code, LangChain Deep Agents），都在趋同于一个共同的、经过实战检验的架构。

- **这个架构是什么？**
  “一个极简的、原子的函数调用层”
  +
  “一个庞大的、可供探索的外部文件系统与脚本库”

- **补充说明**
  这套架构，是整个行业为了平衡“无限的能力扩展”与“有限的上下文窗口”这一核心矛盾，共同演进而来的“最优解”。
